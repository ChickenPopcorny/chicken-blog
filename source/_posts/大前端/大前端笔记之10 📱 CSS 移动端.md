---
title: 大前端笔记之10 📱 CSS 移动端
date: 2020-01-26 9:15:55
abbrlink: x3i0w12c
tags: CSS
categories: 大前端
excerpt: 随着移动设备的普及，Web 开发已经不仅仅是 PC 端的问题了，因此 CSS 提出了很多概念来适应不同的移动设备。
---

# 大前端笔记之10 📱 CSS 移动端

随着移动设备的普及，Web 开发已经不仅仅是 PC 端的问题了，因此 CSS 提出了很多概念来适应不同的移动设备。

## 基本概念

### 英寸

英寸（inch）一般用来描述屏幕的物理大小，如电脑显示器的`17`、`22`，手机显示器的`4.8`、`5.7`等使用的单位都是英寸，而且它们指的是屏幕对角线的长度。

![](http://cdn.yesuanzao.cn/superbed/2020/01/26/5e2ce9fe2fb38b8c3c89e334.jpg)

> inch 在荷兰语中的本意是大拇指，指的是大拇指关节处的宽度，即 1 英寸 = 2.54 厘米。

### 物理像素

物理像素是设备屏幕的真实物理单元，可以简单理解为一组三色的 LED 灯就构成了一个物理像素，如果把屏幕锯掉一半，那么物理像素也就只有之前的一半了。

例如苹果官网上对于各型号手机**像素分辨率**的说明，指的就是物理像素。

![](https://ae01.alicdn.com/kf/H5c41e136b9d34574aface6a57cc1e7cfz.jpg)

### PPI

但是物理像素越高，并不代表屏幕越清晰，因为还得看这些像素放在多大的地方，也就是屏幕的尺寸。于是，只有通过 PPI（Pixel Per Inch，像素每英寸）才可以描述屏幕的清晰度，PPI 越高，屏幕才越清晰（即使屏幕可能会更小），反之则越模糊。

下面是苹果官网对于 XS Max 和 SE 两款设备的说明，可见前者的屏幕是要比后者更加清晰的。

![](https://ae01.alicdn.com/kf/H0680fec6a1ef47e7a843ff795349d91fp.jpg)

PPI 的计算方式也比较简单，只需要将对角线的物理像素数除以对角线的英寸数即可：

$$ PPI=\frac{\sqrt{水平物理像素^2+垂直物理像素^2}}{对角线英寸} $$

如 iPhone SE 的像素分辨率为`1136 × 640`，屏幕大小为`4`英寸，那么它的 PPI 为：

$$ PPI=\frac{\sqrt{1136^2+640^2}}{4}=\frac{1303.88}{4} \approx 326 $$

### 设备独立像素

上面所有的概念都是以物理像素为基础的，但是随着智能手机的发展，人们开始使用手机来阅读文章或图片。如果一段同样的内容，在分辨率`320 × 480`的手机上大小算作正常的话，那么在分辨率为`640 × 960`的手机来看，则会比前者小了一半，原因就是后者的物理像素更多，渲染同样大小的内容只需要更小的空间。可以想象按这样的情况发展，那么更大分辨率的设备就几乎不可能看清上面的内容了。

![](https://ae01.alicdn.com/kf/H9cd218fab1b04d0b9a1551048972d8aeU.jpg)

各个移动设备厂商不可能将这个问题置之不理。乔布斯在 2010 年 iPhone4 发布会上首次提出了 Retina Display（视网膜屏幕）的概念，完美解决了这一问题。

![](https://ae01.alicdn.com/kf/Hf4a428bbd3874b14ab9c2972622d96d6A.jpg)

其大致原理是，通过算法将之前的 1 个物理像素通过 4 个物理像素来渲染（指平面上，而非单个方向）。于是原本正常大小的内容不会被缩小，而是变得更加精细了。

![](https://ae01.alicdn.com/kf/H51b6b477d4024420a40ba9ae120a97faT.png)

也就是说，在上文的例子中，假如内容宽度为`300px`，那么左侧手机依然使用`300px`渲染它，而右侧的手机则会使用`600px`来渲染。于是，这里提出了一个新的概念设备独立像素（Device Independent Pixels，简称 DIP）来描述内容的宽度。由此可见，在 CSS 中使用的单位`px`指的**并不是物理像素，而是设备独立像素**。

### DPR

为了定义这种渲染的比例，又规定了在水平方向或垂直方向上，**物理像素与设备独立像素的比值，称为 DPR（Device Pixel Ratio）**。

如上文中 iPhone4 在水平或垂直方向上将 1 个物理像素通过 2 个物理像素来渲染，因此它的 DPR 就是`2 / 1 = 2`。通过在 Chrome 开发工具中选择不同的设备，然后使用 JavaScript 提供的`window.devicePixelRatio`可以直接查看当前设备的 DPR。

![](https://ae01.alicdn.com/kf/He76b1fc514bb49448edc3f52b2b7b90bV.jpg)

并且，设备名称右侧的分辨率也是以**设备独立像素**为单位的，因此将这个分辨率乘以该设备的 DPR 得到的就是设备的物理像素。以 iPhone6 为例，它的 DPR 为 2，设备独立像素分辨率为`667 × 375`，将其乘以 2 得到的就是物理分辨率`1334 × 750`。

![](https://ae01.alicdn.com/kf/H34d3b75891364383b0bf09e636e4181dg.jpg)

> 注意，有的设备如 iPhone 6 / 7 / 8 Plus 计算的结果并不准确，这是由于苹果通过另外的技术将更多的设备独立像素塞进了物理像素中，不必在意。

后来，各个 Android 厂商也纷纷通过另外的技术实现了类似于苹果的视网膜屏幕，开发了 DPR 高于 1 的设备。

### 多倍图

DPR 还带来了另外一个问题，虽然文字或者图形是通过 CSS 渲染出来的，可以任意放大或缩小，但是如果是固定像素的图片被放大了，那么就会出现模糊的情况。

为了解决这个问题，通常会将原本`50 × 50`图片，先放大一倍也就是变成`100 × 100`，然后在 CSS 中使用`width`或`background-size`将其缩小到`50 × 50`。这样原本不需要缩放的 PC 端依然按照原样显示，而移动端虽然会将其放大，但是图片本身就是`100 × 100`的大小，也不会变的模糊。

```css
img { /* 原图大小 100，实际显示 50 */
    width: 50px;
}
div { /* 原背景大小 100，实际显示 50 */
    background-size: 50px;
}
```

对于 @2x 的精灵图来说，除了要缩小宽高，定位的位置同样也要缩小一半。

```css
/* 精灵图原大小为 400 × 400，原位置在 -166px 0 */
div {
    background: url(sprite.png) no-repeat -83px 0 / 200px;
}
```

### 视口

视口指的是浏览器窗口上能看到页面内容的区域。在移动设备上，由于设备屏幕通常比较窄，因此会使用一种**虚拟视口**（virtual viewport）。它通常比屏幕尺寸要宽，然后将渲染的页面放到虚拟视口中，经过收缩之后显示到屏幕上，从而使用户可以一次性看到整个页面。例如，移动设备的屏幕宽度为`375px`，虚拟视口宽度为`980px`，页面宽度也是`980px`，那么页面会正好完整的显示在`375px`大小的屏幕内。

```css
div {
    border: 2px solid #000; /* 为了看清元素的边界，加了 2px 边框 */
    width: 976px;
}
```

![](http://cdn.yesuanzao.cn/superbed/2020/01/27/5e2e0e902fb38b8c3ca13672.jpg)

> 虚拟视口的宽度根据不同的移动设备会有所不同，Safari 通常为 980px，Opera 为 850px，Android 的 WebKit 为 800px，而 IE 为 974px。

但是这样也存在弊端，`16px`的文字在`980px`的区域中，显示在手机屏幕这么小的范围，虽然不会出现滚动条，但是文字会变得非常小，根本没法看清，用户打开每个页面都必须手动缩放到合适的大小才能查看。并且，这样的方式也没法使用媒体查询技术，因为对于页面来说，它认为所有的设备都是`980px`，没法针对更小的宽度作出更好的响应。

为了解决这个问题，Safari 提供了一个视口标签，使页面开发者可以根据需要自己设定虚拟视口的宽度。

```html
<meta name="viewport" content="width=1200">
```

此时会发现之前`980px`的元素并不能占满整个窗口了。

![](http://cdn.yesuanzao.cn/superbed/2020/01/27/5e2e12e92fb38b8c3ca17373.jpg)

但是，由于移动设备屏幕大小不一，这样的固定视口宽度并没有很大用处。因此，通常会将视口宽度设置成与设备宽度相同。该标签除了宽度以外，还可以设置一些其它的参数：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
```

| 参数 | 描述 |
| --- | --- |
| `width=device-width` | 将视口宽度设置为设备宽度 |
| `initial-scale=1.0` | 设置初始的缩放比率为`1`，即没有缩放 |
| `maximum-scale=1.0` | 设置最大的缩放比率为`1` |
| `minimum-scale=1.0` | 设置最小的缩放比率为`1` |
| `user-scalable` | 不允许用户缩放页面，但是在 iOS10 之后的 Safari 中无效 |

不过这样的弊端也是有的，如果是 PC 端固定宽度的页面，放在较小宽度的视口内，那么就只能显示其中的一部分，用户只能通过进度条才能看到页面其它内容。于是，为了达到理想效果，还需要结合自适应布局、响应式布局、媒体查询甚至针对不同大小重新设计页面布局才可以达到完美的效果。

> *参考资料*
>
> * [Using the viewport meta tag to control layout on mobile browsers](https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag)

## 媒体查询

媒体查询可以使浏览器根据不同的设备类型（比如打印机、屏幕）或者参数（视口宽度）使用不同的样式。

在样式表中通过`@media`可以使用媒体查询：

```css
@media screen and (max-width: 500px) {}
```

或者在`<link>`和`<style>`中使用`media`属性：

```html
<link rel="stylesheet" href="500.css" media="screen and (max-width: 500px)">
<style media="screen and (max-width: 400px)"></style>
```

媒体查询的语法由媒体类型和媒体特性构成，之间使用逻辑运算符相连。

| 媒体查询语法 | 描述 |
| --- | --- |
| 媒体类型 | 即设备的类型，包括全部`all`、打印机`print`和屏幕`screen`，如果省略则默认为`all` |
| 媒体特性 | 必须由**圆括号**`()`包裹，包括`width`和`height`，前面可以加大于等于`min-`或小于等于`max-` |
| 运算符 | 包括逻辑且`and`、逻辑非`not`和逻辑或`,` |

注意，媒体查询的样式也是具有层叠性的，例如：

```css
@media (min-width: 400px) {
    body { background-color: #333; }
}
@media (min-width: 300px) {
    body { background-color: #66ccff; }
}
```

在上面的代码中，由于后者的区间`>=300`包含了前者的区间`>=400`，因此在进行判断时，后者的样式总是会生效。如果要实现`>=400`显示灰色，`300 ~ 400`之间显示蓝色的效果的话，那么必须将两者的顺序调换过来。

## 自适应布局

多数情况下，网页的设计稿只有一份（一般以`750px`为准），因此最简单直接的方案就是在不同的屏幕大小下，都以同样的方式**等比缩放**显示，因此在大屏下看到的文字和元素也更大，这样的方式称为**自适应布局**。不过，虽然在宽度上可以借助百分比单位、弹性布局等多种方式来实现自适应效果，但是高度和文字大小等部分却并没有这么简单。

以京东移动端为例，可以看到同一个底部链接在 iPhone5 和 iPhone6P 下的高度是不同的。

![](http://cdn.yesuanzao.cn/superbed/2020/01/27/5e2e1ead2fb38b8c3ca228a6.jpg)

### rem 实现方式

最初实现自适应布局是通过相对长度单位`rem`，它相对的是根元素`<html>`的`font-size`。例如，`<html>`的`font-size`为`14px`，那么`2rem`就是`28px`。与之类似的`em`是相对于本元素的`font-size`（包括从父元素继承的）。

然后将各个元素的大小都设置为`rem`，再使用媒体查询动态调整`<html>`的`font-size`，就能使相关的元素随之调整。

```css
@media (max-width: 414px) { html { font-size: 41.4px } }
@media (min-width: 320px) { html { font-size: 32px } }

div {
    font-size: .5rem;
    height: 1rem;
    line-height: 1rem;
}
```

![](https://ae01.alicdn.com/kf/H4ffdd6638bc242f898d8af8524ff20f2b.jpg)

为了实现等比缩放，那么必须规定一个统一的**缩放比率**，才能确保不同尺寸下缩放效果相同。例如，假如`750px`设计稿中的`font-size`为`75px`，即缩小十分之一，那么在`320px`下的`font-size`则必须为`32px`，才是同样缩小十分之一。因此，将需要适应的尺寸乘以该比例，得出的就是当前尺寸下的`font-size`。

```css
@media (max-width: 750px) {
    html { font-size: 75px; /* 750px / 10 */ }
}
@media (max-width: 320px) {
    html { font-size: 32px; /* 320px / 10 */ }
}
```

> 常见的尺寸有`320px`、`360px`、`375px`、`384px`、`400px`、`414px`、`424px`、`480px`、`540px`、`720px`、`750px`，更高尺寸的屏幕以`750px`即设计稿原始大小为准即可。

接下来，假如一个元素在`750px`设计稿中的高度为`100px`，由于此时`1rem = 75px`，那么它的高度`100px`换算成`rem`应该是：

```less
div { height: 1.33rem; /* 100 / 75 */ }
```

如果屏幕大小缩小一半为`375px`，那么计算此时的高度为`1.33rem = 1.33 × 37.5px = 49.8px`，基本为原大小的一半，可见结果是正确的。

> 淘宝基于这种原理开发了一款插件[flexible.js](https://github.com/amfe/lib-flexible)，可以节省手写媒体查询的步骤。但是由于`rem`的局限性以及`vw`兼容性的提高，这款插件已经停止开发。

### vw 实现方式

相对长度单位`vw`与`rem`类似，但是它是根据视口宽度来计算的，表示**视口宽度除以`100`**。比如视口的宽度是`750px`，那么`1vw`就相当于`7.5px`。

它的实际使用方式同样与`rem`类似，以大多数设计稿的尺寸`750px`为例，`1vw`就相当于`7.5px`。因此，一个高度为`100px` 的元素，换算后的结果为：

```less
div { height: 13.33vw; /* 100 / 7.5 */ }
```

可以看到这种方式相当于省略了媒体查询，将单位直接与视口挂钩，使用起来更加方便，完全可以取代`rem`方式。此外，如果觉得手动计算比较麻烦，可以使用插件，比如 VSCode 的 px2vw。

### 响应式布局

虽然在不同的屏幕大小上直接等比缩放比较方便，但是这样的方式其实有些简单粗暴了。更加理想的是，**屏幕越大看到的内容应该越多，而不是将字变得更大**。

因此，针对不同的屏幕大小，可以给出多份设计稿（通常包含 PC、手机端、平板三种尺寸）然后开发人员借助媒体查询，可以使元素在不同设备上呈现特定的效果（比如在移动端隐藏侧边栏、改变导航栏布局等），这样的方式称为响应式布局。

下面是 Bootstrap 中给出的屏幕尺寸，可以作为参考：

| 设备 | 尺寸 | 容器宽度 |
| --- | --- | --- |
| 手机 | `< 768px` | `100%`   |
| 平板 | `768px ~ 991px` | `750px`  |
| 小型桌面显示器 | `992px ~ 1199px` | `970px`  |
| 大型桌面显示器 | `≥ 1200px` | `1170px` |

```css
.container {
    width: 1280px; /* 默认的 PC 端 */
}

@media (max-width: 1199px) { /* 小型显示器 */
    .container { width: 970px; }
}
@media (max-width: 991px) { /* 平板 */
    .container { width: 750px; }
}
@media (max-width: 767px) { /* 手机 */
    .container { width: 100%; }
}
```